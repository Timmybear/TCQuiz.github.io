<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pixel Reveal - Masked Reveal Edition</title>
  <style>
    :root {
      --bg: #000000;
      --text: #ffffff;
      --primary: #4f46e5;
      --success: #059669;
      --border: #333333;
    }

    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background-color: var(--bg);
      color: var(--text);
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }

    .screen {
      display: none;
      flex-direction: column;
      align-items: center;
      width: 90%;
      max-width: 900px;
      text-align: center;
    }

    #setup-area {
      display: flex;
      border: 1px solid var(--border);
      padding: 40px;
      border-radius: 20px;
      background: #080808;
      flex-direction: column;
      align-items: center;
    }

    input[type="text"], input[type="file"], select {
      background: #111;
      border: 1px solid var(--border);
      color: white;
      padding: 12px;
      margin: 10px 0;
      border-radius: 8px;
      width: 80%;
    }

    .hint {
      width: 80%;
      margin: 0 0 10px 0;
      font-size: 0.95rem;
      color: #cfcfcf;
      text-align: left;
      white-space: pre-wrap;
    }

    .instruction-container { text-align: center; margin: 25px 0; }
    .instruction-list {
      text-align: left;
      display: inline-block;
      margin: 25px 0;
      font-size: 1.2rem;
      line-height: 1.8;
    }
    b { color: var(--text); font-weight: 800; }

    #answerDisplay {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 10px;
      height: 3.8rem;
      text-transform: capitalize;
      visibility: hidden;
    }

    .image-box {
      width: 100%;
      height: 55vh;
      background: #000;
      border-radius: 16px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      position: relative;
    }

    .reveal-svg {
      width: 100%;
      height: 100%;
      display: block;
      opacity: 0;
      transition: opacity 0.25s ease-in;
    }

    .ui-top {
      width: 100%;
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
      font-weight: 600;
    }

    .controls { margin-top: 30px; display: flex; gap: 20px; justify-content: center; }

    button {
      padding: 16px 45px;
      font-size: 1.1rem;
      font-weight: 700;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-primary { background: var(--primary); color: white; }
    .btn-success { background: var(--success); color: white; }
    button:hover { transform: translateY(-2px); filter: brightness(1.2); }

    .home-link{
      position: fixed;
      top: 18px;
      left: 18px;
      z-index: 9999;
      color: var(--text);
      text-decoration: none;
      font-weight: 700;
      font-size: 0.95rem;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(8,8,8,0.85);
      backdrop-filter: blur(6px);
    }
    .home-link:hover{ filter: brightness(1.2); transform: translateY(-1px); }
  </style>
</head>

<body>
  <a class="home-link" href="index.html">← Home</a>

  <div id="setup-area" class="screen" style="display:flex;">
    <h1 style="margin-top:0;">Activity Setup</h1>
    <p>Enter the Quiz Topic</p>
    <input type="text" id="topicInput" placeholder="e.g. Movie Quiz" />

    <p>Select Quiz Source</p>
    <select id="quizSelect">
      <option value="upload">Upload images (from your device)</option>
      <option value="pr_quiz1">Pre-loaded quiz 1</option>
      <option value="pr_quiz2">Pre-loaded quiz 2</option>
    </select>
    <div id="quizSourceHint" class="hint"></div>

    <p id="uploadLabel">Select Images</p>
    <input type="file" id="imageInput" multiple accept="image/*" />
    <br />
    <button class="btn-primary" onclick="showCoverPage()">Generate Quiz</button>
  </div>

  <div id="cover-page" class="screen">
    <h1 id="displayTopic" style="font-size: 4rem; margin-bottom: 0;">QUIZ TOPIC</h1>
    <h3 style="margin-top: 5px; opacity: 0.7; text-transform: uppercase;">How to play</h3>
    <div class="instruction-container">
      <ul class="instruction-list">
        <li>A highly blurred image will be displayed at first</li>
        <li>Use the <b>Chat</b> or <b>Audio</b> to guess what the image is</li>
        <li>Each click reveals more detail (4 stages total)</li>
        <li>The final click reveals the clear image and the answer</li>
      </ul>
    </div>
    <div class="controls">
      <button class="btn-success" onclick="startGame()">Start Session →</button>
    </div>
  </div>

  <div id="game-container" class="screen">
    <div id="answerDisplay">The Answer</div>

    <div class="ui-top">
      <span id="imgCounter">Challenge 1</span>
      <span style="border: 1px solid white; padding: 4px 15px; border-radius: 20px;" id="blurLabel">Blur: 15%</span>
    </div>

    <div class="image-box" id="imageBox"></div>

    <div class="controls">
      <button id="revealBtn" class="btn-primary" onclick="stepReveal()">Reveal Next Step</button>
      <button id="nextBtn" class="btn-success" onclick="nextImg()" style="display:none;">Next Image →</button>
    </div>
  </div>

  <script>
    // -------------------------
    // Game state
    // -------------------------
    let fileObjs = [];
    let curIdx = 0;
    let curStep = 0;
    let curObjectUrl = null;

    // Reveal design
    const GRID = 10;
    const TOTAL_BLOCKS = GRID * GRID;

    // -------------------------
    // Pre-loaded quiz sets
    // -------------------------
    const PRELOADED_QUIZZES = {
      pr_quiz1: { label: "Pre-loaded quiz 1", basePath: "./quizzes/pixel-reveal/pr_quiz1/" },
      pr_quiz2: { label: "Pre-loaded quiz 2", basePath: "./quizzes/pixel-reveal/pr_quiz2/" }
    };

    // ✅ If your GitHub Pages is served from gh-pages branch or /docs, you can hard-set these.
    // Leave them blank to use auto-detection + fallback attempts.
    const GITHUB_CONFIG = {
      owner: "",        // e.g. "Timmybear"  (optional)
      repo: "",         // e.g. "Timmybear.github.io" or "my-project-repo" (optional)
      ref: "",          // e.g. "gh-pages" (optional)
      contentRoot: ""   // e.g. "docs" if Pages source is /docs (optional)
    };

    function uniq(arr) {
      const out = [];
      for (const v of arr) if (v && !out.includes(v)) out.push(v);
      return out;
    }

    function encodePathSegments(path) {
      return String(path || "")
        .split("/")
        .filter(Boolean)
        .map(encodeURIComponent)
        .join("/");
    }

    function inferGithubRepoFromLocation() {
      const host = window.location.hostname || "";
      if (!host.endsWith("github.io")) return null;

      const owner = host.split(".")[0] || "";
      const seg = (window.location.pathname || "").split("/").filter(Boolean);

      // Project pages: https://<owner>.github.io/<repo>/
      // User pages:    https://<owner>.github.io/  (repo is <owner>.github.io)
      const repo = seg.length > 0 ? seg[0] : `${owner}.github.io`;

      if (!owner || !repo) return null;
      return { owner, repo };
    }

    async function fetchRepoDefaultBranch(owner, repo) {
      try {
        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
          headers: { "Accept": "application/vnd.github+json" }
        });
        if (!res.ok) return "";
        const data = await res.json();
        return data && data.default_branch ? String(data.default_branch) : "";
      } catch {
        return "";
      }
    }

    // Try listing contents with different (ref, root) combos to avoid 404 due to Pages source settings.
    async function listGithubDirSmart(dirPathInRepo) {
      const inferred = inferGithubRepoFromLocation();
      const owner = (GITHUB_CONFIG.owner || (inferred && inferred.owner) || "").trim();
      const repo  = (GITHUB_CONFIG.repo  || (inferred && inferred.repo)  || "").trim();

      if (!owner || !repo) {
        throw new Error(
          "Could not infer GitHub owner/repo.\n\n" +
          "Fix: set GITHUB_CONFIG.owner and GITHUB_CONFIG.repo in the code."
        );
      }

      const defaultBranch = await fetchRepoDefaultBranch(owner, repo);

      const refs = uniq([
        GITHUB_CONFIG.ref,
        defaultBranch,
        "gh-pages",
        "main",
        "master"
      ]).filter(Boolean);

      // If no branch detected, still attempt without ?ref (API default)
      const refCandidates = refs.length ? refs : [""];

      const roots = uniq([
        GITHUB_CONFIG.contentRoot,
        "",       // repo root
        "docs"    // common Pages source
      ]);

      const attempted = [];

      for (const root of roots) {
        const base = root ? `${root.replace(/\/$/, "")}/` : "";
        const fullPath = `${base}${dirPathInRepo}`.replace(/\/{2,}/g, "/").replace(/^\/+/, "");

        for (const ref of refCandidates) {
          const refQ = ref ? `?ref=${encodeURIComponent(ref)}` : "";
          const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encodePathSegments(fullPath)}${refQ}`;
          attempted.push(apiUrl);

          const res = await fetch(apiUrl, { headers: { "Accept": "application/vnd.github+json" } });

          if (res.ok) {
            const data = await res.json();
            if (!Array.isArray(data)) {
              throw new Error("Unexpected response when listing pre-loaded quiz folder.");
            }
            return { data, owner, repo, ref: ref || defaultBranch || "", root };
          }

          // continue trying other combos
        }
      }

      throw new Error(
        "Could not list pre-loaded quiz folder via GitHub API (HTTP 404).\n\n" +
        "Most common fixes:\n" +
        "1) Your GitHub Pages is served from the 'gh-pages' branch → set GITHUB_CONFIG.ref = 'gh-pages'\n" +
        "2) Your GitHub Pages is served from '/docs' → set GITHUB_CONFIG.contentRoot = 'docs'\n" +
        "3) Your site is hosted from a different repo → set GITHUB_CONFIG.owner/repo\n\n" +
        "Tried:\n" + attempted.slice(0, 6).join("\n") + (attempted.length > 6 ? "\n..." : "")
      );
    }

    function isImageFilename(name) {
      return /\.(png|jpe?g)$/i.test(name || "");
    }

    // Use GitHub API's download_url (points to the correct branch) so we don't rely on site-relative paths.
    async function buildPreloadedFileObjs(sourceKey) {
      const quiz = PRELOADED_QUIZZES[sourceKey];
      if (!quiz) throw new Error("Unknown pre-loaded quiz selection.");

      const dir = String(quiz.basePath || "")
        .replace(/^\.\//, "")
        .replace(/\/$/, "");

      const listed = await listGithubDirSmart(dir);
      const items = listed.data;

      const files = items
        .filter(it => it && it.type === "file" && isImageFilename(it.name) && it.download_url)
        .map(it => ({
          kind: "url",
          url: it.download_url,
          name: it.name
        }));

      if (files.length === 0) {
        throw new Error("No .png/.jpg/.jpeg images found in the selected pre-loaded quiz folder.");
      }

      files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: "base" }));
      return files;
    }

    // -------------------------
    // Filename / answer helpers
    // -------------------------
    function filenameFromUrl(url) {
      const clean = (url || "").split("?")[0].split("#")[0];
      const parts = clean.split("/");
      const last = parts[parts.length - 1] || "";
      try { return decodeURIComponent(last); } catch { return last; }
    }

    function displayNameFromFilename(filename) {
      return String(filename || "")
        .split(".")
        .slice(0, -1)
        .join(".")
        .replace(/[_-]/g, " ");
    }

    function getItemFilename(item) {
      if (!item) return "";
      if (item.kind === "file" && item.file) return item.file.name || "";
      if (item.kind === "url") {
        if (item.name) return item.name;
        if (item.url) return filenameFromUrl(item.url);
      }
      return item.name || "";
    }

    // -------------------------
    // UI helpers
    // -------------------------
    function updateQuizSourceUi() {
      const sel = document.getElementById("quizSelect");
      const uploadLabel = document.getElementById("uploadLabel");
      const uploadInput = document.getElementById("imageInput");
      const hint = document.getElementById("quizSourceHint");

      if (!sel || !uploadLabel || !uploadInput || !hint) return;

      if (sel.value === "upload") {
        uploadLabel.style.display = "block";
        uploadInput.style.display = "block";
        hint.textContent = "Upload images from your device.";
      } else {
        uploadLabel.style.display = "none";
        uploadInput.style.display = "none";
        const quiz = PRELOADED_QUIZZES[sel.value];
        hint.textContent = quiz
          ? `Using ${quiz.label} (auto-loading images from repo folder).`
          : "Using a pre-loaded quiz set.";
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      const sel = document.getElementById("quizSelect");
      if (sel) sel.addEventListener("change", updateQuizSourceUi);
      updateQuizSourceUi();
    });

    // -------------------------
    // Reveal stages
    // -------------------------
    const STAGES = [
      { blurPercent: 40, revealCount: 0,   showAnswer: false },
      { blurPercent: 20, revealCount: 20,  showAnswer: false },
      { blurPercent: 15, revealCount: 50,  showAnswer: false },
      { blurPercent: 0,  revealCount: 100, showAnswer: true  }
    ];

    let tileOrder = [];

    // -------------------------
    // UI flow
    // -------------------------
    async function showCoverPage() {
      const source = document.getElementById('quizSelect').value;
      const input = document.getElementById('imageInput');
      const topic = document.getElementById('topicInput').value;

      try {
        if (source === 'upload') {
          if (input.files.length === 0) return alert("Please select images.");
          fileObjs = Array.from(input.files).map(f => ({ kind: 'file', file: f, name: f.name }));
        } else {
          fileObjs = await buildPreloadedFileObjs(source);
        }

        if (fileObjs.length === 0) return alert("No images found for this quiz.");

        curIdx = 0;

        document.getElementById('displayTopic').innerText = topic || "The Pixel Reveal";
        document.getElementById('setup-area').style.display = 'none';
        document.getElementById('cover-page').style.display = 'flex';
      } catch (err) {
        alert(err && err.message ? err.message : String(err));
      }
    }

    function startGame() {
      document.getElementById('cover-page').style.display = 'none';
      document.getElementById('game-container').style.display = 'flex';
      loadLevel();
    }

    // -------------------------
    // Blur logic (same as before)
    // -------------------------
    function percentToBlurPx(pct) {
      return Math.max(0, pct * 0.8);
    }

    function setFilterRegion(filterEl, w, h, blurPx) {
      const pad = Math.max(40, blurPx * 6);
      filterEl.setAttribute("filterUnits", "userSpaceOnUse");
      filterEl.setAttribute("x", String(-pad));
      filterEl.setAttribute("y", String(-pad));
      filterEl.setAttribute("width", String(w + pad * 2));
      filterEl.setAttribute("height", String(h + pad * 2));
    }

    // -------------------------
    // SVG build
    // -------------------------
    function buildRevealSvg(w, h) {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("class", "reveal-svg");
      svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

      const defs = document.createElementNS(svg.namespaceURI, "defs");

      const filter = document.createElementNS(svg.namespaceURI, "filter");
      filter.setAttribute("id", "blurFilter");

      const feBlur = document.createElementNS(svg.namespaceURI, "feGaussianBlur");
      feBlur.setAttribute("id", "blurNode");
      feBlur.setAttribute("in", "SourceGraphic");
      feBlur.setAttribute("stdDeviation", "0");
      feBlur.setAttribute("edgeMode", "duplicate");

      filter.appendChild(feBlur);
      defs.appendChild(filter);

      const mask = document.createElementNS(svg.namespaceURI, "mask");
      mask.setAttribute("id", "revealMask");

      const maskBg = document.createElementNS(svg.namespaceURI, "rect");
      maskBg.setAttribute("x", "0");
      maskBg.setAttribute("y", "0");
      maskBg.setAttribute("width", String(w));
      maskBg.setAttribute("height", String(h));
      maskBg.setAttribute("fill", "black");

      const maskGroup = document.createElementNS(svg.namespaceURI, "g");
      maskGroup.setAttribute("id", "maskRects");

      mask.appendChild(maskBg);
      mask.appendChild(maskGroup);
      defs.appendChild(mask);

      svg.appendChild(defs);

      const imgBlur = document.createElementNS(svg.namespaceURI, "image");
      imgBlur.setAttribute("id", "imgBlur");
      imgBlur.setAttribute("x", "0");
      imgBlur.setAttribute("y", "0");
      imgBlur.setAttribute("width", String(w));
      imgBlur.setAttribute("height", String(h));
      imgBlur.setAttribute("preserveAspectRatio", "xMidYMid meet");
      imgBlur.setAttribute("filter", "url(#blurFilter)");

      const imgClear = document.createElementNS(svg.namespaceURI, "image");
      imgClear.setAttribute("id", "imgClear");
      imgClear.setAttribute("x", "0");
      imgClear.setAttribute("y", "0");
      imgClear.setAttribute("width", String(w));
      imgClear.setAttribute("height", String(h));
      imgClear.setAttribute("preserveAspectRatio", "xMidYMid meet");
      imgClear.setAttribute("mask", "url(#revealMask)");

      svg.appendChild(imgBlur);
      svg.appendChild(imgClear);

      return svg;
    }

    function setSvgImageHref(svg, url) {
      const blur = svg.querySelector("#imgBlur");
      const clear = svg.querySelector("#imgClear");

      blur.setAttribute("href", url);
      clear.setAttribute("href", url);

      blur.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", url);
      clear.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", url);
    }

    function applyStage(svg, stepIdx) {
      const stage = STAGES[stepIdx];

      const blurPx = percentToBlurPx(stage.blurPercent);
      const blurNode = svg.querySelector("#blurNode");
      blurNode.setAttribute("stdDeviation", String(blurPx));

      const vb = svg.viewBox.baseVal;
      const filterEl = svg.querySelector("#blurFilter");
      setFilterRegion(filterEl, vb.width, vb.height, blurPx);

      const maskGroup = svg.querySelector("#maskRects");
      maskGroup.innerHTML = "";

      const revealCount = Math.min(stage.revealCount, TOTAL_BLOCKS);
      const cellW = vb.width / GRID;
      const cellH = vb.height / GRID;

      for (let i = 0; i < revealCount; i++) {
        const idx = tileOrder[i];
        const r = Math.floor(idx / GRID);
        const c = idx % GRID;

        const rect = document.createElementNS(svg.namespaceURI, "rect");
        rect.setAttribute("x", String(c * cellW));
        rect.setAttribute("y", String(r * cellH));
        rect.setAttribute("width", String(cellW));
        rect.setAttribute("height", String(cellH));
        rect.setAttribute("fill", "white");

        maskGroup.appendChild(rect);
      }

      document.getElementById('blurLabel').innerText = `Blur: ${stage.blurPercent}%`;

      if (stage.showAnswer) {
        document.getElementById('answerDisplay').style.visibility = 'visible';
        document.getElementById('revealBtn').style.display = 'none';
        document.getElementById('nextBtn').style.display = 'block';
      } else {
        document.getElementById('answerDisplay').style.visibility = 'hidden';
        document.getElementById('revealBtn').style.display = 'block';
        document.getElementById('nextBtn').style.display = 'none';
      }
    }

    // -------------------------
    // Deterministic shuffle
    // -------------------------
    function hashStringToSeed(str) {
      let h = 2166136261;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }

    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function makeTileOrder(seedStr) {
      const seed = hashStringToSeed(seedStr);
      const rand = mulberry32(seed);

      const arr = Array.from({ length: TOTAL_BLOCKS }, (_, i) => i);
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // -------------------------
    // Level loading
    // -------------------------
    function loadLevel() {
      curStep = 0;

      const item = fileObjs[curIdx];
      const imageBox = document.getElementById('imageBox');
      const ans = document.getElementById('answerDisplay');

      if (curObjectUrl && curObjectUrl.startsWith('blob:')) {
        URL.revokeObjectURL(curObjectUrl);
      }
      curObjectUrl = null;

      const filename = getItemFilename(item);
      const name = displayNameFromFilename(filename);
      ans.innerText = name;
      ans.style.visibility = 'hidden';

      document.getElementById('imgCounter').innerText = `Challenge ${curIdx + 1} of ${fileObjs.length}`;
      tileOrder = makeTileOrder(filename || String(curIdx));

      imageBox.innerHTML = '';

      const rect = imageBox.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      const svg = buildRevealSvg(w, h);
      imageBox.appendChild(svg);

      let src = '';
      if (item && item.kind === 'file' && item.file) {
        curObjectUrl = URL.createObjectURL(item.file);
        src = curObjectUrl;
      } else if (item && item.kind === 'url' && item.url) {
        src = item.url;
      } else {
        alert("Invalid image item in quiz set.");
        return location.reload();
      }

      const pre = new Image();
      pre.onload = () => {
        setSvgImageHref(svg, src);
        applyStage(svg, 0);
        requestAnimationFrame(() => { svg.style.opacity = "1"; });
      };

      pre.onerror = () => {
        alert(`Could not load image: ${filename}

URL tried:
${src}

Check:
1) File exists in the repo folder
2) Filename casing matches exactly (GitHub is case-sensitive)
3) The file is committed/pushed`);
        location.reload();
      };

      pre.src = src;

      document.getElementById('revealBtn').style.display = 'block';
      document.getElementById('nextBtn').style.display = 'none';
      document.getElementById('blurLabel').innerText = `Blur: ${STAGES[0].blurPercent}%`;
    }

    function stepReveal() {
      const svg = document.querySelector('#imageBox .reveal-svg');
      if (!svg) return;

      if (curStep < STAGES.length - 1) {
        curStep++;
        applyStage(svg, curStep);
      }
    }

    function nextImg() {
      if (curIdx < fileObjs.length - 1) {
        curIdx++;
        loadLevel();
      } else {
        alert("Quiz Complete! Great job team.");
        location.reload();
      }
    }
  </script>
</body>
</html>
